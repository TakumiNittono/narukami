# 07. 通知送信フロー設計書

## 概要

Vercel Cron Jobsを使い、定期的に予約通知をチェック・送信する。
firebase-admin SDK を使用し、登録済み全ユーザーに一斉送信する。

---

## 送信方式

### 予約送信（メイン）
- **Vercel Cron Jobsが5分間隔で実行**
- `/api/cron/send-scheduled` エンドポイントをGETで呼び出す
- 未送信かつ送信時刻を過ぎた通知を検出し、全ユーザーに一斉送信

### テスト送信
- 管理画面の「テスト送信」ボタンから即時実行
- `POST /api/send-notification` を呼び出す
- 全ユーザーに送信（MVPでは個別送信なし）

---

## Vercel Cron Jobs 設定

### vercel.json

```json
{
  "crons": [
    {
      "path": "/api/cron/send-scheduled",
      "schedule": "*/5 * * * *"
    }
  ]
}
```

### 注意事項
- **Hobbyプラン（無料）**: 1日1回まで（`0 * * * *` 等）
- **Proプラン（$20/月）**: 毎分まで設定可能（`*/5 * * * *`）
- MVPでは **Hobbyプランの場合は1時間間隔** で開始し、必要に応じてProに移行

#### Hobbyプランの場合の代替設定
```json
{
  "crons": [
    {
      "path": "/api/cron/send-scheduled",
      "schedule": "0 * * * *"
    }
  ]
}
```
> 1時間ごとの実行。送信時刻に最大59分の誤差が出るが、MVPとしては許容。

---

## cron送信フロー詳細

### フローチャート

```
[Vercel Cron 起動]
        │
        ▼
[GET /api/cron/send-scheduled]
        │
        ▼
[CRON_SECRET 認証チェック]
        │
        ├── 認証失敗 → 401 返却、終了
        │
        ▼
[Supabase: 未送信通知を取得]
  notifications WHERE sent=false AND send_at <= NOW()
        │
        ├── 0件 → 200 返却（何もしない）
        │
        ▼ 1件以上
[Supabase: 全ユーザーのトークンを取得]
  users SELECT fcm_token
        │
        ├── 0件 → 200 返却（送信先なし）
        │
        ▼ 1件以上
[firebase-admin 初期化]
        │
        ▼
[通知ごとにループ]
    │
    ▼
  [sendEachForMulticast で一斉送信]
    │
    ├── 成功/失敗カウント
    │
    ▼
  [Supabase: sent = true に更新]
    │
    ▼
  [次の通知へ]
│
[全通知処理完了 → 200 返却]
```

---

## 実装

### api/cron/send-scheduled.js

```javascript
import { supabaseAdmin } from '../../lib/supabase.js';
import { getFirebaseAdmin } from '../../lib/firebase-admin.js';

export default async function handler(req, res) {
    // Vercel Cron認証
    if (req.headers['authorization'] !== `Bearer ${process.env.CRON_SECRET}`) {
        return res.status(401).json({ status: 'error', message: 'Unauthorized' });
    }

    try {
        // ===== STEP 1: 未送信通知を取得 =====
        const { data: notifications, error: notifError } = await supabaseAdmin
            .from('notifications')
            .select('*')
            .eq('sent', false)
            .lte('send_at', new Date().toISOString())
            .order('send_at', { ascending: true });

        if (notifError) throw notifError;

        if (!notifications || notifications.length === 0) {
            return res.status(200).json({ status: 'ok', message: 'No pending notifications' });
        }

        // ===== STEP 2: 全ユーザートークン取得 =====
        const { data: users, error: userError } = await supabaseAdmin
            .from('users')
            .select('fcm_token');

        if (userError) throw userError;

        if (!users || users.length === 0) {
            return res.status(200).json({ status: 'ok', message: 'No users to send' });
        }

        const tokens = users.map(u => u.fcm_token);
        const admin = getFirebaseAdmin();
        const results = [];

        // ===== STEP 3: 通知ごとに送信 =====
        for (const notification of notifications) {
            const message = {
                notification: {
                    title: notification.title,
                    body: notification.body,
                },
                webpush: {
                    notification: {
                        icon: '/icons/icon-192.png',
                        badge: '/icons/icon-192.png',
                        requireInteraction: false,
                    },
                    fcmOptions: {
                        link: notification.url || '/',
                    },
                },
                tokens,
            };

            const response = await admin.messaging().sendEachForMulticast(message);

            // ===== STEP 4: 送信済みに更新 =====
            await supabaseAdmin
                .from('notifications')
                .update({ sent: true })
                .eq('id', notification.id);

            results.push({
                id: notification.id,
                title: notification.title,
                success: response.successCount,
                failure: response.failureCount,
            });

            console.log(
                `[Cron] 通知ID:${notification.id} 送信完了 `
                + `成功:${response.successCount} 失敗:${response.failureCount}`
            );
        }

        return res.status(200).json({
            status: 'ok',
            message: `${notifications.length} notifications sent`,
            results,
        });
    } catch (err) {
        console.error('[Cron] Error:', err);
        return res.status(500).json({ status: 'error', message: err.message });
    }
}
```

---

## firebase-admin 一斉送信

### sendEachForMulticast の特徴

| 項目 | 説明 |
|---|---|
| 最大トークン数 | **500個/リクエスト** |
| 戻り値 | `successCount` + `failureCount` + 各トークンの結果 |
| 自動リトライ | なし（自前で実装が必要な場合） |

### 500人以上の場合のバッチ処理

```javascript
// 500件ずつ分割して送信
async function sendToAllUsers(admin, tokens, notification) {
    const batchSize = 500;
    let totalSuccess = 0;
    let totalFailure = 0;

    for (let i = 0; i < tokens.length; i += batchSize) {
        const batch = tokens.slice(i, i + batchSize);

        const message = {
            notification: {
                title: notification.title,
                body: notification.body,
            },
            webpush: {
                notification: {
                    icon: '/icons/icon-192.png',
                },
                fcmOptions: {
                    link: notification.url || '/',
                },
            },
            tokens: batch,
        };

        const response = await admin.messaging().sendEachForMulticast(message);
        totalSuccess += response.successCount;
        totalFailure += response.failureCount;
    }

    return { totalSuccess, totalFailure };
}
```

---

## パフォーマンス考慮

### Vercel Serverless Functionの制約

| プラン | 最大実行時間 | メモリ |
|---|---|---|
| Hobby（無料） | **10秒** | 1024MB |
| Pro（$20/月） | **60秒**（設定で300秒まで） | 1024MB〜3008MB |

### 送信時間の目安（sendEachForMulticast使用時）

| ユーザー数 | 推定送信時間 | Hobbyプラン | Proプラン |
|---|---|---|---|
| 100人 | 約1〜2秒 | ○ | ○ |
| 500人 | 約3〜5秒 | ○ | ○ |
| 1,000人 | 約5〜10秒 | △（ギリギリ） | ○ |
| 5,000人 | 約20〜30秒 | ✕ | ○ |

> **Hobbyプランでは500人程度まで安全に送信可能**
> それ以上はProプランへの移行を推奨

### Vercel Functionタイムアウト設定（Proプラン）

```javascript
// api/cron/send-scheduled.js の先頭に追加
export const config = {
    maxDuration: 300,  // 最大300秒（Proプランのみ）
};
```

---

## エラーハンドリング

### FCMエラー対応

| エラー | 対応 |
|---|---|
| `messaging/registration-token-not-registered` | トークン無効（ログ出力、Phase2で削除） |
| `messaging/invalid-argument` | ログ出力、スキップ |
| その他 | ログ出力、続行 |

### 再送防止

```
[通知取得] → [全ユーザーに送信] → [sent = true 更新]
```

- 送信途中でタイムアウトした場合 → 次のcronで再送される可能性あり
- MVPでは許容（同じ通知が2回届く可能性あり）
- Phase2でトランザクション管理を検討

---

## ログ

### Vercelログ
- `console.log()` → Vercelダッシュボードの **Functions** タブで確認可能
- Runtime Logsでリアルタイム確認

### ログ出力例

```
[Cron] 送信対象: 2件の通知, 対象ユーザー: 150人
[Cron] 通知ID:5 送信完了 成功:148 失敗:2
[Cron] 通知ID:6 送信完了 成功:150 失敗:0
[Cron] 全通知処理完了
```
